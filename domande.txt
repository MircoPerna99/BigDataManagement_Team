Here are 10 meaningful decision-support queries for this healthcare database, covering clinical, operational, and financial aspects:

1. Patient Medication Adherence Analysis
sql
SELECT p.id, p.first, p.last, 
       COUNT(DISTINCT m.code) AS medications_prescribed,
       AVG(DATEDIFF(IFNULL(m.stop, CURDATE()), m.start)) AS avg_days_on_medication
FROM patients p
JOIN medications m ON p.id = m.patient
WHERE m.stop IS NULL OR m.stop > CURDATE()
GROUP BY p.id
ORDER BY avg_days_on_medication DESC;
Purpose: Identify patients with long-term medication needs for adherence programs.

2. High-Cost Procedure Analysis
sql
SELECT pr.description, 
       COUNT(*) AS procedure_count,
       AVG(pr.base_cost) AS avg_cost,
       SUM(pr.base_cost) AS total_cost
FROM procedures pr
WHERE pr.start BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY pr.code, pr.description
HAVING total_cost > 10000
ORDER BY total_cost DESC;
Purpose: Identify most expensive procedures for cost management.

3. Chronic Condition Prevalence
sql
SELECT c.description, 
       COUNT(DISTINCT c.patient) AS patient_count,
       ROUND(COUNT(DISTINCT c.patient) * 100.0 / 
             (SELECT COUNT(*) FROM patients), 2) AS prevalence_percentage
FROM conditions c
WHERE c.stop IS NULL
GROUP BY c.description
ORDER BY patient_count DESC
LIMIT 10;
Purpose: Identify most common chronic conditions for resource planning.

4. Insurance Coverage Gaps
sql
SELECT py.name AS payer,
       COUNT(DISTINCT pt.patient) AS patients_covered,
       SUM(CASE WHEN pt.end_year < CURDATE() AND pt.secondary_payer IS NULL THEN 1 ELSE 0 END) AS coverage_gaps
FROM payer_transitions pt
JOIN payers py ON pt.payer = py.id
GROUP BY py.name
ORDER BY coverage_gaps DESC;
Purpose: Identify insurance coverage gaps that may lead to uncompensated care.

5. Provider Productivity Report
sql
SELECT pr.name, pr.speciality,
       COUNT(DISTINCT e.id) AS encounters,
       COUNT(DISTINCT e.patient) AS unique_patients,
       SUM(e.base_encounter_cost) AS total_value
FROM providers pr
JOIN encounters e ON pr.id = e.provider
WHERE e.start BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY pr.id, pr.name, pr.speciality
ORDER BY total_value DESC;
Purpose: Evaluate provider productivity and patient load distribution.

6. Drug Cost vs. Effectiveness
sql
SELECT m.description,
       COUNT(DISTINCT m.patient) AS patients_treated,
       AVG(m.base_cost) AS avg_cost,
       (SELECT COUNT(*) FROM conditions c 
        WHERE c.patient IN (SELECT patient FROM medications WHERE code = m.code)
        AND c.stop IS NULL) AS active_conditions
FROM medications m
GROUP BY m.code, m.description
ORDER BY patients_treated DESC, avg_cost DESC;
Purpose: Analyze medication cost versus patient outcomes.

7. Claim Denial Patterns
sql
SELECT c.status1, c.status2, c.statusp,
       COUNT(*) AS claim_count,
       AVG(c.outstanding1) AS avg_outstanding
FROM claims c
WHERE c.lastbilleddate1 BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.status1, c.status2, c.statusp
ORDER BY claim_count DESC;
Purpose: Identify common claim denial reasons for process improvement.

8. Preventive Care Compliance
sql
SELECT p.id, p.first, p.last, p.gender, p.birthdate,
       (SELECT COUNT(*) FROM immunizations i 
        WHERE i.patient = p.id AND i.date > DATE_SUB(CURDATE(), INTERVAL 3 YEAR)) AS recent_vaccinations,
       (SELECT COUNT(*) FROM careplans cp 
        WHERE cp.patient = p.id AND cp.stop IS NULL) AS active_careplans
FROM patients p
WHERE p.birthdate < DATE_SUB(CURDATE(), INTERVAL 50 YEAR)
ORDER BY recent_vaccinations, active_careplans;
Purpose: Identify patients needing preventive care follow-ups.

9. Facility Utilization Analysis
sql
SELECT o.name, 
       COUNT(DISTINCT e.id) AS encounters,
       COUNT(DISTINCT e.provider) AS providers,
       SUM(e.base_encounter_cost) AS total_revenue,
       o.utilization
FROM organizations o
JOIN encounters e ON o.id = e.organization
WHERE e.start BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY o.id, o.name, o.utilization
ORDER BY utilization DESC;
Purpose: Evaluate facility usage versus capacity.

10. Patient Risk Stratification
sql
SELECT p.id, p.first, p.last,
       COUNT(DISTINCT c.code) AS chronic_conditions,
       COUNT(DISTINCT a.code) AS allergies,
       COUNT(DISTINCT m.code) AS medications,
       p.healthcare_expenses
FROM patients p
LEFT JOIN conditions c ON p.id = c.patient AND c.stop IS NULL
LEFT JOIN allergies a ON p.id = a.patient
LEFT JOIN medications m ON p.id = m.patient
GROUP BY p.id, p.first, p.last, p.healthcare_expenses
ORDER BY chronic_conditions DESC, healthcare_expenses DESC;
Purpose: Identify high-risk patients for care management programs.